<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Room Assignments and JotForm Submissions</title>
<style>
  body { font-family: Arial, sans-serif; max-width: 900px; margin: auto; padding: 1rem; }
  h2 { border-bottom: 2px solid #ccc; padding-bottom: 0.25rem; }
  section { margin-bottom: 2rem; }
  ul { list-style: none; padding-left: 0; }
  li { padding: 0.25rem 0; }
  .completed { color: green; }
  .overdue { color: red; }
</style>
</head>
<body>
<h1>Room Assignments and Submissions</h1>

<div id="content">Loading data...</div>

<script>
// Configs
const API_KEY = '5b9a10e2092947d49dac84004ad149a2';
const ROOM_FORM_ID = '250955404825056';
const ROOM_FIELD_ID = '18';
const BRIAN_FORM_ID = '251415718602049';
const STATUS_FIELD_ID = '9';
const ASSIGNED_TO_FIELD_ID = '10';
const BRIAN_NAME = 'Brian';

// Utility: Parse CSV from fetch text
function parseCSV(text) {
  const lines = text.trim().split('\n');
  const headers = lines.shift().split(',');
  return lines.map(line => {
    const cols = line.split(',');
    let obj = {};
    headers.forEach((h,i) => obj[h.trim()] = cols[i].trim());
    return obj;
  });
}

// Utility: Get previous Monday from today
function getPreviousMonday() {
  const now = new Date();
  const day = now.getDay();
  const diff = (day === 1) ? 0 : (day + 6) % 7; // days since previous Monday
  now.setHours(0,0,0,0);
  now.setDate(now.getDate() - diff);
  return now;
}

// Fetch CSV and parse
async function loadCSV() {
  const res = await fetch('./rooms-shifts.csv');
  const text = await res.text();
  return parseCSV(text);
}

// JotForm API fetch helper with pagination support if needed
async function fetchJotFormSubmissions(formId) {
  const url = `https://api.jotform.com/form/${formId}/submissions?apiKey=${API_KEY}&limit=1000`;
  const res = await fetch(url);
  const json = await res.json();
  if(json.responseCode !== 200) throw new Error('Failed fetching submissions for form ' + formId);
  return json.content;
}

// Decode option keys in submission answers (like {key})
function decodeOptionValue(field, key) {
  if(!field || !field.options_array) return null;
  try {
    const opts = JSON.parse(field.options_array);
    return opts[key]?.value || null;
  } catch {
    return null;
  }
}

// Main render function
async function main() {
  const content = document.getElementById('content');
  content.textContent = 'Loading rooms data...';
  const rooms = await loadCSV();

  content.textContent = 'Loading room form submissions...';
  const roomSubmissions = await fetchJotFormSubmissions(ROOM_FORM_ID);

  content.textContent = 'Loading Brian form submissions...';
  const brianSubmissions = await fetchJotFormSubmissions(BRIAN_FORM_ID);

  // Compute previous Monday datetime for filtering
  const prevMonday = getPreviousMonday();

  // Filter room form submissions completed since previous Monday
  // Rooms completed = those with matching room field answer and created_at >= prevMonday
  const completedRoomsSet = new Set();
  for (const sub of roomSubmissions) {
    const created = new Date(sub.created_at);
    if (created >= prevMonday) {
      const answers = sub.answers || {};
      const roomAnswer = answers[ROOM_FIELD_ID]?.answer;
      if(roomAnswer) {
        completedRoomsSet.add(roomAnswer);
      }
    }
  }

  // Group rooms by Assigned and Day
  const roomsByAssigned = {};
  for(const room of rooms) {
    if(!roomsByAssigned[room.Assigned]) roomsByAssigned[room.Assigned] = [];
    roomsByAssigned[room.Assigned].push(room);
  }

  // Decode Brian form assigned and status answers helper
  function isBrianAssignedAndNotCompleted(sub) {
    const answers = sub.answers || {};
    const statusField = answers[STATUS_FIELD_ID];
    const assignedField = answers[ASSIGNED_TO_FIELD_ID];
    if(!statusField || !assignedField) return false;

    const statusKey = statusField.answer.replace(/[{}]/g,'');
    const assignedKeys = Array.isArray(assignedField.answer) ? assignedField.answer : [assignedField.answer];
    const assignedKeyClean = assignedKeys.map(k => k.replace(/[{}]/g,''));

    const statusLabel = decodeOptionValue(statusField, statusKey);
    const assignedLabels = assignedKeyClean.map(k => decodeOptionValue(assignedField, k));

    return assignedLabels.includes(BRIAN_NAME) && statusLabel !== 'Completed';
  }

  // Filter Brian submissions that are assigned to Brian and not completed
  const filteredBrianSubs = brianSubmissions.filter(isBrianAssignedAndNotCompleted);

  // Build the HTML per Assigned person
  let html = '';

  for(const assigned in roomsByAssigned) {
    html += `<section><h2>${assigned}</h2>`;

    const assignedRooms = roomsByAssigned[assigned];
    // For simplicity, we assume today is Monday or filter by Day === today (optional)
    // But the user example showed all on Monday, so let's filter rooms due today only by Day = current day string
    const days = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
    const todayStr = days[new Date().getDay()];
    
    // Rooms due today (Day matches today) and not completed
    const dueTodayRooms = assignedRooms.filter(r => r.Day === todayStr && !completedRoomsSet.has(r.Room));
    // Rooms overdue (Day before today or previous Monday but not completed)
    // Overdue means any room assigned that is not completed and whose Day < today? Let's define overdue as all rooms assigned with Day before today that are not completed
    const overdueRooms = assignedRooms.filter(r => {
      // Convert day name to number
      const dayNum = days.indexOf(r.Day);
      const todayNum = days.indexOf(todayStr);
      return dayNum < todayNum && !completedRoomsSet.has(r.Room);
    });

    // Due Today Section
    html += `<h3>Due today</h3>`;
    if(dueTodayRooms.length === 0) {
      html += `<p><em>None</em></p>`;
    } else {
      html += `<ul>`;
      for(const room of dueTodayRooms) {
        html += `<li>${room.Room}</li>`;
      }
      html += `</ul>`;
    }

    // Add Brian's incomplete submissions at bottom of Due Today ONLY for Brian assigned
    if(assigned.toLowerCase() === 'brian') {
      html += `<h4>Brian's open submissions</h4>`;
      if(filteredBrianSubs.length === 0) {
        html += `<p><em>None</em></p>`;
      } else {
        html += `<ul>`;
        for(const sub of filteredBrianSubs) {
          const nameAnswer = sub.answers['3']?.prettyFormat || 'Unknown';
          const desc = sub.answers['6']?.answer || '';
          const createdAt = new Date(sub.created_at).toLocaleString();
          html += `<li><strong>${nameAnswer}</strong>: ${desc} <br/><small>Submitted: ${createdAt}</small></li>`;
        }
        html += `</ul>`;
      }
    }

    // Overdue Section
    html += `<h3>Overdue</h3>`;
    if(overdueRooms.length === 0) {
      html += `<p><em>None</em></p>`;
    } else {
      html += `<ul>`;
      for(const room of overdueRooms) {
        html += `<li>${room.Room}</li>`;
      }
      html += `</ul>`;
    }

    // Show "See Brian for additional items" if all rooms complete
    if(dueTodayRooms.length === 0 && overdueRooms.length === 0) {
      html += `<p><strong>See Brian for additional items.</strong></p>`;
    }

    html += `</section>`;
  }

  content.innerHTML = html;
}

main().catch(err => {
  document.getElementById('content').textContent = 'Error loading data: ' + err.message;
});
</script>
</body>
</html>
